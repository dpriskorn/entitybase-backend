from _typeshed import Incomplete
from collections.abc import Callable as Callable
from socket import socket
from typing import Any
from uvicorn._subprocess import get_subprocess as get_subprocess
from uvicorn.config import Config as Config

SIGNALS: Incomplete
logger: Incomplete

class Process:
    real_target: Incomplete
    process: Incomplete
    def __init__(
        self,
        config: Config,
        target: Callable[[list[socket] | None], None],
        sockets: list[socket],
    ) -> None: ...
    def ping(self, timeout: float = 5) -> bool: ...
    def pong(self) -> None: ...
    def always_pong(self) -> None: ...
    def target(self, sockets: list[socket] | None = None) -> Any: ...
    def is_alive(self, timeout: float = 5) -> bool: ...
    def start(self) -> None: ...
    def terminate(self) -> None: ...
    def kill(self) -> None: ...
    def join(self) -> None: ...
    @property
    def pid(self) -> int | None: ...

class Multiprocess:
    config: Incomplete
    target: Incomplete
    sockets: Incomplete
    processes_num: Incomplete
    processes: list[Process]
    should_exit: Incomplete
    signal_queue: list[int]
    def __init__(
        self,
        config: Config,
        target: Callable[[list[socket] | None], None],
        sockets: list[socket],
    ) -> None: ...
    def init_processes(self) -> None: ...
    def terminate_all(self) -> None: ...
    def join_all(self) -> None: ...
    def restart_all(self) -> None: ...
    def run(self) -> None: ...
    def keep_subprocess_alive(self) -> None: ...
    def handle_signals(self) -> None: ...
    def handle_int(self) -> None: ...
    def handle_term(self) -> None: ...
    def handle_break(self) -> None: ...
    def handle_hup(self) -> None: ...
    def handle_ttin(self) -> None: ...
    def handle_ttou(self) -> None: ...
