from _typeshed import Incomplete
from decimal import Decimal
from rdflib.namespace import XSD as XSD
from rdflib.plugins.sparql.datatypes import type_promotion as type_promotion
from rdflib.plugins.sparql.operators import numeric as numeric
from rdflib.plugins.sparql.parserutils import CompValue as CompValue
from rdflib.plugins.sparql.sparql import (
    FrozenBindings as FrozenBindings,
    NotBoundError as NotBoundError,
    SPARQLTypeError as SPARQLTypeError,
)
from rdflib.term import (
    BNode as BNode,
    Identifier as Identifier,
    Literal as Literal,
    URIRef as URIRef,
    Variable as Variable,
)
from typing import Any, Callable, Mapping, MutableMapping, overload

class Accumulator:
    get_value: Callable[[], Literal | None]
    update: Callable[[FrozenBindings, Aggregator], None]
    var: Incomplete
    expr: Incomplete
    distinct: bool
    seen: set[Any]
    def __init__(self, aggregation: CompValue) -> None: ...
    def dont_care(self, row: FrozenBindings) -> bool: ...
    def use_row(self, row: FrozenBindings) -> bool: ...
    def set_value(self, bindings: MutableMapping[Variable, Identifier]) -> None: ...

class Counter(Accumulator):
    value: int
    def __init__(self, aggregation: CompValue) -> None: ...
    def update(self, row: FrozenBindings, aggregator: Aggregator) -> None: ...
    def get_value(self) -> Literal: ...
    def eval_row(self, row: FrozenBindings) -> Identifier: ...
    def eval_full_row(self, row: FrozenBindings) -> FrozenBindings: ...
    def use_row(self, row: FrozenBindings) -> bool: ...

@overload
def type_safe_numbers(*args: int) -> tuple[int]: ...
@overload
def type_safe_numbers(*args: Decimal | float | int) -> tuple[float | int]: ...

class Sum(Accumulator):
    value: int
    datatype: str | None
    def __init__(self, aggregation: CompValue) -> None: ...
    def update(self, row: FrozenBindings, aggregator: Aggregator) -> None: ...
    def get_value(self) -> Literal: ...

class Average(Accumulator):
    counter: int
    sum: int
    datatype: str | None
    def __init__(self, aggregation: CompValue) -> None: ...
    def update(self, row: FrozenBindings, aggregator: Aggregator) -> None: ...
    def get_value(self) -> Literal: ...

class Extremum(Accumulator):
    compare: Callable[[Any, Any], Any]
    value: Any
    use_row: Incomplete
    def __init__(self, aggregation: CompValue) -> None: ...
    def set_value(self, bindings: MutableMapping[Variable, Identifier]) -> None: ...
    def update(self, row: FrozenBindings, aggregator: Aggregator) -> None: ...

class Minimum(Extremum):
    def compare(self, val1: _ValueT, val2: _ValueT) -> _ValueT: ...

class Maximum(Extremum):
    def compare(self, val1: _ValueT, val2: _ValueT) -> _ValueT: ...

class Sample(Accumulator):
    use_row: Incomplete
    def __init__(self, aggregation) -> None: ...
    def update(self, row: FrozenBindings, aggregator: Aggregator) -> None: ...
    def get_value(self) -> None: ...

class GroupConcat(Accumulator):
    value: list[Literal]
    separator: str
    def __init__(self, aggregation: CompValue) -> None: ...
    def update(self, row: FrozenBindings, aggregator: Aggregator) -> None: ...
    def get_value(self) -> Literal: ...

class Aggregator:
    accumulator_classes: Incomplete
    bindings: dict[Variable, Identifier]
    accumulators: dict[str, Accumulator]
    def __init__(self, aggregations: list[CompValue]) -> None: ...
    def update(self, row: FrozenBindings) -> None: ...
    def get_bindings(self) -> Mapping[Variable, Identifier]: ...
