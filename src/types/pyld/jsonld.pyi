from .context_resolver import ContextResolver as ContextResolver
from _typeshed import Incomplete
from pyld.__about__ import (
    __copyright__ as __copyright__,
    __license__ as __license__,
    __version__ as __version__,
)
from typing import NamedTuple

__all__ = [
    "__copyright__",
    "__license__",
    "__version__",
    "compact",
    "expand",
    "flatten",
    "frame",
    "link",
    "from_rdf",
    "to_rdf",
    "normalize",
    "set_document_loader",
    "get_document_loader",
    "parse_link_header",
    "load_document",
    "requests_document_loader",
    "aiohttp_document_loader",
    "register_rdf_parser",
    "unregister_rdf_parser",
    "JsonLdProcessor",
    "JsonLdError",
    "ContextResolver",
    "freeze",
]

def compact(input_, ctx, options=None): ...
def expand(input_, options=None): ...
def flatten(input_, ctx=None, options=None): ...
def frame(input_, frame, options=None): ...
def link(input_, ctx, options=None): ...
def normalize(input_, options=None): ...
def from_rdf(input_, options=None): ...
def to_rdf(input_, options=None): ...
def set_document_loader(load_document_) -> None: ...
def get_document_loader(): ...
def parse_link_header(header): ...
def requests_document_loader(**kwargs): ...
def aiohttp_document_loader(**kwargs): ...
def register_rdf_parser(content_type, parser) -> None: ...
def unregister_rdf_parser(content_type) -> None: ...

class ParsedUrl(NamedTuple):
    scheme: Incomplete
    authority: Incomplete
    path: Incomplete
    query: Incomplete
    fragment: Incomplete

class JsonLdProcessor:
    rdf_parsers: Incomplete
    def __init__(self) -> None: ...
    def compact(self, input_, ctx, options): ...
    def expand(self, input_, options): ...
    def flatten(self, input_, ctx, options): ...
    def frame(self, input_, frame, options): ...
    def normalize(self, input_, options): ...
    def from_rdf(self, dataset, options): ...
    def to_rdf(self, input_, options): ...
    def process_context(self, active_ctx, local_ctx, options): ...
    def register_rdf_parser(self, content_type, parser) -> None: ...
    def unregister_rdf_parser(self, content_type) -> None: ...
    @staticmethod
    def has_property(subject, property): ...
    @staticmethod
    def has_value(subject, property, value): ...
    @staticmethod
    def add_value(subject, property, value, options={}) -> None: ...
    @staticmethod
    def get_values(subject, property): ...
    @staticmethod
    def remove_property(subject, property) -> None: ...
    @staticmethod
    def remove_value(subject, property, value, options={}): ...
    @staticmethod
    def compare_values(v1, v2): ...
    @staticmethod
    def get_context_value(ctx, key, type_): ...
    @staticmethod
    def parse_nquads(input_): ...
    @staticmethod
    def to_nquads(dataset): ...
    @staticmethod
    def to_nquad(triple, graph_name=None): ...
    @staticmethod
    def arrayify(value): ...

class JsonLdError(Exception):
    type: Incomplete
    details: Incomplete
    code: Incomplete
    cause: Incomplete
    causeTrace: Incomplete
    def __init__(self, message, type_, details=None, code=None, cause=None) -> None: ...

class IdentifierIssuer:
    prefix: Incomplete
    counter: int
    existing: Incomplete
    order: Incomplete
    def __init__(self, prefix) -> None: ...
    def get_id(self, old=None): ...
    def has_id(self, old): ...

class URDNA2015:
    blank_node_info: Incomplete
    hash_to_blank_nodes: Incomplete
    canonical_issuer: Incomplete
    quads: Incomplete
    POSITIONS: Incomplete
    def __init__(self) -> None: ...
    def main(self, dataset, options): ...
    def hash_first_degree_quads(self, id_): ...
    def modify_first_degree_component(self, id_, component, key): ...
    def hash_related_blank_node(self, related, quad, issuer, position): ...
    def get_related_predicate(self, quad): ...
    def hash_n_degree_quads(self, id_, issuer): ...
    def create_hash_to_related(self, id_, issuer): ...
    def create_hash(self): ...
    def hash_nquads(self, nquads): ...

class URGNA2012(URDNA2015):
    def __init__(self) -> None: ...
    def modify_first_degree_component(self, id_, component, key): ...
    def get_related_predicate(self, quad): ...
    def create_hash_to_related(self, id_, issuer): ...
    def create_hash(self): ...

def freeze(value): ...
def load_document(url, options, base=None, profile=None, requestProfile=None): ...
