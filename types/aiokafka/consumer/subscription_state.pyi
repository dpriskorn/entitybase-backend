import contextlib
from _typeshed import Incomplete
from aiokafka.abc import ConsumerRebalanceListener as ConsumerRebalanceListener
from aiokafka.errors import IllegalStateError as IllegalStateError
from aiokafka.structs import (
    OffsetAndMetadata as OffsetAndMetadata,
    TopicPartition as TopicPartition,
)
from aiokafka.util import (
    create_future as create_future,
    get_running_loop as get_running_loop,
)
from collections.abc import Generator, Iterable
from enum import Enum
from re import Pattern

log: Incomplete

class SubscriptionType(Enum):
    NONE = 1
    AUTO_TOPICS = 2
    AUTO_PATTERN = 3
    USER_ASSIGNED = 4

class SubscriptionState:
    def __init__(self, loop=None) -> None: ...
    @property
    def subscription(self) -> Subscription: ...
    @property
    def subscribed_pattern(self) -> Pattern: ...
    @property
    def listener(self) -> ConsumerRebalanceListener: ...
    @property
    def topics(self): ...
    def assigned_partitions(self) -> set[TopicPartition]: ...
    @property
    def reassignment_in_progress(self): ...
    def partitions_auto_assigned(self) -> bool: ...
    def is_assigned(self, tp: TopicPartition) -> bool: ...
    def subscribe(self, topics: set[str], listener=None): ...
    def subscribe_pattern(self, pattern: Pattern, listener=None): ...
    def assign_from_user(self, partitions: Iterable[TopicPartition]): ...
    def unsubscribe(self) -> None: ...
    def subscribe_from_pattern(self, topics: set[str]): ...
    def assign_from_subscribed(self, assignment: set[TopicPartition]): ...
    def begin_reassignment(self) -> None: ...
    def seek(self, tp: TopicPartition, offset: int): ...
    def wait_for_subscription(self): ...
    def wait_for_assignment(self): ...
    def register_fetch_waiters(self, waiters) -> None: ...
    def abort_waiters(self, exc) -> None: ...
    def pause(self, tp: TopicPartition) -> None: ...
    def paused_partitions(self) -> set[TopicPartition]: ...
    def resume(self, tp: TopicPartition) -> None: ...
    @contextlib.contextmanager
    def fetch_context(self) -> Generator[None]: ...
    @property
    def fetcher_idle_time(self): ...

class Subscription:
    unsubscribe_future: Future
    def __init__(self, topics: Iterable[str], loop=None) -> None: ...
    @property
    def active(self): ...
    @property
    def topics(self): ...
    @property
    def assignment(self): ...

class ManualSubscription(Subscription):
    def __init__(
        self, user_assignment: Iterable[TopicPartition], loop=None
    ) -> None: ...

class Assignment:
    unassign_future: Incomplete
    commit_refresh_needed: Incomplete
    def __init__(self, topic_partitions: Iterable[TopicPartition]) -> None: ...
    @property
    def tps(self): ...
    @property
    def active(self): ...
    def state_value(self, tp: TopicPartition) -> TopicPartitionState: ...
    def all_consumed_offsets(self) -> dict[TopicPartition, OffsetAndMetadata]: ...
    def requesting_committed(self): ...

class PartitionStatus(Enum):
    AWAITING_RESET = 0
    CONSUMING = 1
    UNASSIGNED = 2

class TopicPartitionState:
    highwater: Incomplete
    lso: Incomplete
    timestamp: Incomplete
    def __init__(self, assignment) -> None: ...
    @property
    def paused(self): ...
    @property
    def resume_fut(self): ...
    @property
    def has_valid_position(self) -> bool: ...
    @property
    def position(self) -> int: ...
    @property
    def awaiting_reset(self): ...
    @property
    def reset_strategy(self) -> int: ...
    def await_reset(self, strategy) -> None: ...
    def fetch_committed(self): ...
    def update_committed(self, offset_meta: OffsetAndMetadata): ...
    def consumed_to(self, position: int): ...
    def reset_to(self, position: int): ...
    def seek(self, position: int): ...
    def wait_for_position(self): ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
