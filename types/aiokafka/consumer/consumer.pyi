from .fetcher import Fetcher as Fetcher, OffsetResetStrategy as OffsetResetStrategy
from .group_coordinator import (
    GroupCoordinator as GroupCoordinator,
    NoGroupCoordinator as NoGroupCoordinator,
)
from .subscription_state import SubscriptionState as SubscriptionState
from _typeshed import Incomplete
from aiokafka import __version__ as __version__
from aiokafka.abc import ConsumerRebalanceListener as ConsumerRebalanceListener
from aiokafka.client import AIOKafkaClient as AIOKafkaClient
from aiokafka.coordinator.assignors.roundrobin import (
    RoundRobinPartitionAssignor as RoundRobinPartitionAssignor,
)
from aiokafka.errors import (
    ConsumerStoppedError as ConsumerStoppedError,
    IllegalOperation as IllegalOperation,
    IllegalStateError as IllegalStateError,
    RecordTooLargeError as RecordTooLargeError,
)
from aiokafka.structs import (
    ConsumerRecord as ConsumerRecord,
    TopicPartition as TopicPartition,
)
from aiokafka.util import (
    commit_structure_validate as commit_structure_validate,
    get_running_loop as get_running_loop,
)

log: Incomplete

class AIOKafkaConsumer:
    def __init__(
        self,
        *topics,
        loop=None,
        bootstrap_servers: str = "localhost",
        client_id=...,
        group_id=None,
        group_instance_id=None,
        key_deserializer=None,
        value_deserializer=None,
        fetch_max_wait_ms: int = 500,
        fetch_max_bytes: int = 52428800,
        fetch_min_bytes: int = 1,
        max_partition_fetch_bytes=...,
        request_timeout_ms=...,
        retry_backoff_ms: int = 100,
        auto_offset_reset: str = "latest",
        enable_auto_commit: bool = True,
        auto_commit_interval_ms: int = 5000,
        check_crcs: bool = True,
        metadata_max_age_ms=...,
        partition_assignment_strategy=...,
        max_poll_interval_ms: int = 300000,
        rebalance_timeout_ms=None,
        session_timeout_ms: int = 10000,
        heartbeat_interval_ms: int = 3000,
        consumer_timeout_ms: int = 200,
        max_poll_records=None,
        ssl_context=None,
        security_protocol: str = "PLAINTEXT",
        exclude_internal_topics: bool = True,
        connections_max_idle_ms: int = 540000,
        isolation_level: str = "read_uncommitted",
        sasl_mechanism: str = "PLAIN",
        sasl_plain_password=None,
        sasl_plain_username=None,
        sasl_kerberos_service_name: str = "kafka",
        sasl_kerberos_domain_name=None,
        sasl_oauth_token_provider=None,
    ) -> None: ...
    def __del__(self, _warnings=...) -> None: ...
    async def start(self) -> None: ...
    def assign(self, partitions) -> None: ...
    def assignment(self): ...
    async def stop(self) -> None: ...
    async def commit(self, offsets=None) -> None: ...
    async def committed(self, partition): ...
    async def topics(self): ...
    def partitions_for_topic(self, topic): ...
    async def position(self, partition): ...
    def highwater(self, partition): ...
    def last_stable_offset(self, partition): ...
    def last_poll_timestamp(self, partition): ...
    def seek(self, partition, offset) -> None: ...
    async def seek_to_beginning(self, *partitions): ...
    async def seek_to_end(self, *partitions): ...
    async def seek_to_committed(self, *partitions): ...
    async def offsets_for_times(self, timestamps): ...
    async def beginning_offsets(self, partitions): ...
    async def end_offsets(self, partitions): ...
    def subscribe(self, topics=(), pattern=None, listener=None) -> None: ...
    def subscription(self): ...
    def unsubscribe(self) -> None: ...
    async def getone(self, *partitions) -> ConsumerRecord: ...
    async def getmany(
        self, *partitions, timeout_ms: int = 0, max_records=None
    ) -> dict[TopicPartition, list[ConsumerRecord]]: ...
    def pause(self, *partitions) -> None: ...
    def paused(self): ...
    def resume(self, *partitions) -> None: ...
    def __aiter__(self): ...
    async def __anext__(self) -> ConsumerRecord: ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type, exc, tb) -> None: ...
