from _typeshed import Incomplete
from decimal import Decimal
from rdflib.graph import Graph, QuotedGraph
from rdflib.parser import InputSource, Parser
from rdflib.term import (
    BNode,
    IdentifiedNode,
    Identifier,
    Literal,
    Node,
    URIRef,
    Variable,
)
from typing import Any, Callable, IO, MutableSequence, NoReturn

__all__ = [
    "BadSyntax",
    "N3Parser",
    "TurtleParser",
    "splitFragP",
    "join",
    "base",
    "runNamespace",
    "uniqueURI",
    "hexify",
    "Formula",
    "RDFSink",
    "SinkParser",
    "sfloat",
]

def splitFragP(uriref: str, punc: int = 0) -> tuple[str, str]: ...
def join(here: str, there: str) -> str: ...
def base() -> str: ...

List_NS = RDF_NS_URI

def runNamespace() -> str: ...
def uniqueURI() -> str: ...

N3_forSome_URI = forSomeSym
N3_forAll_URI = forAllSym

class sfloat(str): ...

class SinkParser:
    lines: int
    startOfLine: int
    keywords: Incomplete
    keywordsSet: int
    turtle: Incomplete
    string_delimiters: Incomplete
    def __init__(
        self,
        store: RDFSink,
        openFormula: Formula | None = None,
        thisDoc: str = "",
        baseURI: str | None = None,
        genPrefix: str = "",
        why: Callable[[], None] | None = None,
        turtle: bool = False,
    ) -> None: ...
    def here(self, i: int) -> str: ...
    def formula(self) -> Formula | None: ...
    def loadStream(self, stream: IO[str] | IO[bytes]) -> Formula | None: ...
    def loadBuf(self, buf: str | bytes) -> Formula | None: ...
    def feed(self, octets: str | bytes) -> None: ...
    def directiveOrStatement(self, argstr: str, h: int) -> int: ...
    def tok(self, tok: str, argstr: str, i: int, colon: bool = False) -> int: ...
    def sparqlTok(self, tok: str, argstr: str, i: int) -> int: ...
    def directive(self, argstr: str, i: int) -> int: ...
    def sparqlDirective(self, argstr: str, i: int) -> int: ...
    def bind(self, qn: str, uri: bytes) -> None: ...
    def setKeywords(self, k: list[str] | None) -> None: ...
    def startDoc(self) -> None: ...
    def endDoc(self) -> Formula | None: ...
    def makeStatement(self, quadruple) -> None: ...
    def statement(self, argstr: str, i: int) -> int: ...
    def subject(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def verb(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def prop(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def item(self, argstr: str, i, res: MutableSequence[Any]) -> int: ...
    def blankNode(self, uri: str | None = None) -> BNode: ...
    def path(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def anonymousNode(self, ln: str) -> BNode: ...
    def node(
        self,
        argstr: str,
        i: int,
        res: MutableSequence[Any],
        subjectAlready: Node | None = None,
    ) -> int: ...
    def property_list(self, argstr: str, i: int, subj: Node) -> int: ...
    def commaSeparatedList(
        self,
        argstr: str,
        j: int,
        res: MutableSequence[Any],
        what: Callable[[str, int, MutableSequence[Any]], int],
    ) -> int: ...
    def objectList(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def checkDot(self, argstr: str, i: int) -> int: ...
    def uri_ref2(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def skipSpace(self, argstr: str, i: int) -> int: ...
    def variable(self, argstr: str, i: int, res) -> int: ...
    def bareWord(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def qname(
        self, argstr: str, i: int, res: MutableSequence[Identifier | tuple[str, str]]
    ) -> int: ...
    def object(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def nodeOrLiteral(self, argstr: str, i: int, res: MutableSequence[Any]) -> int: ...
    def uriOf(self, sym: Identifier | tuple[str, str]) -> str: ...
    def strconst(self, argstr: str, i: int, delim: str) -> tuple[int, str]: ...
    def uEscape(self, argstr: str, i: int, startline: int) -> tuple[int, str]: ...
    def UEscape(self, argstr: str, i: int, startline: int) -> tuple[int, str]: ...
    def BadSyntax(self, argstr: str, i: int, msg: str) -> NoReturn: ...

class BadSyntax(SyntaxError):
    lines: Incomplete
    def __init__(self, uri: str, lines: int, argstr: str, i: int, why: str) -> None: ...
    @property
    def message(self) -> str: ...

class Formula:
    number: int
    uuid: Incomplete
    counter: int
    existentials: dict[str, BNode]
    universals: dict[str, BNode]
    quotedgraph: Incomplete
    def __init__(self, parent: Graph) -> None: ...
    def id(self) -> BNode: ...
    def newBlankNode(self, uri: str | None = None, why: Any | None = None) -> BNode: ...
    def newUniversal(self, uri: str, why: Any | None = None) -> Variable: ...
    def declareExistential(self, x: str) -> None: ...
    def close(self) -> QuotedGraph: ...

class RDFSink:
    rootFormula: Formula | None
    uuid: Incomplete
    counter: int
    graph: Incomplete
    def __init__(self, graph: Graph) -> None: ...
    def newFormula(self) -> Formula: ...
    def newGraph(self, identifier: Identifier) -> Graph: ...
    def newSymbol(self, *args: str) -> URIRef: ...
    def newBlankNode(
        self,
        arg: Formula | Graph | Any | None = None,
        uri: str | None = None,
        why: Callable[[], None] | None = None,
    ) -> BNode: ...
    def newLiteral(self, s: str, dt: URIRef | None, lang: str | None) -> Literal: ...
    def newList(self, n: list[Any], f: Formula | None) -> IdentifiedNode: ...
    def newSet(self, *args: _AnyT) -> set[_AnyT]: ...
    def setDefaultNamespace(self, *args: bytes) -> str: ...
    def makeStatement(
        self,
        quadruple: tuple[Formula | Graph | None, Node, Node, Node],
        why: Any | None = None,
    ) -> None: ...
    def normalise(
        self,
        f: Formula | None,
        n: tuple[int, str] | bool | int | Decimal | sfloat | _AnyT,
    ) -> URIRef | Literal | BNode | _AnyT: ...
    def intern(self, something: _AnyT) -> _AnyT: ...
    def bind(self, pfx, uri) -> None: ...
    def startDoc(self, formula: Formula | None) -> None: ...
    def endDoc(self, formula: Formula | None) -> None: ...

def hexify(ustr: str) -> bytes: ...

class TurtleParser(Parser):
    def __init__(self) -> None: ...
    def parse(
        self,
        source: InputSource,
        graph: Graph,
        encoding: str | None = "utf-8",
        turtle: bool = True,
    ) -> None: ...

class N3Parser(TurtleParser):
    def __init__(self) -> None: ...
    def parse(
        self, source: InputSource, graph: Graph, encoding: str | None = "utf-8"
    ) -> None: ...
