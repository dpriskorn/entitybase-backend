import datetime as py_datetime
from _typeshed import Incomplete
from rdflib.namespace import RDF as RDF, XSD as XSD
from rdflib.plugins.sparql.datatypes import (
    XSD_DTs as XSD_DTs,
    XSD_DateTime_DTs as XSD_DateTime_DTs,
    XSD_Duration_DTs as XSD_Duration_DTs,
    type_promotion as type_promotion,
)
from rdflib.plugins.sparql.parserutils import CompValue as CompValue, Expr as Expr
from rdflib.plugins.sparql.sparql import (
    FrozenBindings as FrozenBindings,
    QueryContext as QueryContext,
    SPARQLError as SPARQLError,
    SPARQLTypeError as SPARQLTypeError,
)
from rdflib.term import (
    BNode as BNode,
    IdentifiedNode as IdentifiedNode,
    Identifier as Identifier,
    Literal as Literal,
    Node as Node,
    URIRef as URIRef,
    Variable as Variable,
)
from rdflib.xsd_datetime import Duration as Duration, parse_datetime as parse_datetime
from typing import Any, Callable, NoReturn, overload

def Builtin_IRI(expr: Expr, ctx: FrozenBindings) -> URIRef: ...
def Builtin_isBLANK(expr: Expr, ctx: FrozenBindings) -> Literal: ...
def Builtin_isLITERAL(expr, ctx) -> Literal: ...
def Builtin_isIRI(expr, ctx) -> Literal: ...
def Builtin_isNUMERIC(expr, ctx) -> Literal: ...
def Builtin_BNODE(expr, ctx) -> BNode: ...
def Builtin_ABS(expr: Expr, ctx) -> Literal: ...
def Builtin_IF(expr: Expr, ctx): ...
def Builtin_RAND(expr: Expr, ctx) -> Literal: ...
def Builtin_UUID(expr: Expr, ctx) -> URIRef: ...
def Builtin_STRUUID(expr, ctx) -> Literal: ...
def Builtin_MD5(expr: Expr, ctx) -> Literal: ...
def Builtin_SHA1(expr: Expr, ctx) -> Literal: ...
def Builtin_SHA256(expr: Expr, ctx) -> Literal: ...
def Builtin_SHA384(expr: Expr, ctx) -> Literal: ...
def Builtin_SHA512(expr: Expr, ctx) -> Literal: ...
def Builtin_COALESCE(expr: Expr, ctx): ...
def Builtin_CEIL(expr: Expr, ctx) -> Literal: ...
def Builtin_FLOOR(expr: Expr, ctx) -> Literal: ...
def Builtin_ROUND(expr: Expr, ctx) -> Literal: ...
def Builtin_REGEX(expr: Expr, ctx) -> Literal: ...
def Builtin_REPLACE(expr: Expr, ctx) -> Literal: ...
def Builtin_STRDT(expr: Expr, ctx) -> Literal: ...
def Builtin_STRLANG(expr: Expr, ctx) -> Literal: ...
def Builtin_CONCAT(expr: Expr, ctx) -> Literal: ...
def Builtin_STRSTARTS(expr: Expr, ctx) -> Literal: ...
def Builtin_STRENDS(expr: Expr, ctx) -> Literal: ...
def Builtin_STRBEFORE(expr: Expr, ctx) -> Literal: ...
def Builtin_STRAFTER(expr: Expr, ctx) -> Literal: ...
def Builtin_CONTAINS(expr: Expr, ctx) -> Literal: ...
def Builtin_ENCODE_FOR_URI(expr: Expr, ctx) -> Literal: ...
def Builtin_SUBSTR(expr: Expr, ctx) -> Literal: ...
def Builtin_STRLEN(e: Expr, ctx) -> Literal: ...
def Builtin_STR(e: Expr, ctx) -> Literal: ...
def Builtin_LCASE(e: Expr, ctx) -> Literal: ...
def Builtin_LANGMATCHES(e: Expr, ctx) -> Literal: ...
def Builtin_NOW(e: Expr, ctx) -> Literal: ...
def Builtin_YEAR(e: Expr, ctx) -> Literal: ...
def Builtin_MONTH(e: Expr, ctx) -> Literal: ...
def Builtin_DAY(e: Expr, ctx) -> Literal: ...
def Builtin_HOURS(e: Expr, ctx) -> Literal: ...
def Builtin_MINUTES(e: Expr, ctx) -> Literal: ...
def Builtin_SECONDS(e: Expr, ctx) -> Literal: ...
def Builtin_TIMEZONE(e: Expr, ctx) -> Literal: ...
def Builtin_TZ(e: Expr, ctx) -> Literal: ...
def Builtin_UCASE(e: Expr, ctx) -> Literal: ...
def Builtin_LANG(e: Expr, ctx) -> Literal: ...
def Builtin_DATATYPE(e: Expr, ctx) -> str | None: ...
def Builtin_sameTerm(e: Expr, ctx) -> Literal: ...
def Builtin_BOUND(e: Expr, ctx) -> Literal: ...
def Builtin_EXISTS(e: Expr, ctx: FrozenBindings) -> Literal: ...
def register_custom_function(
    uri: URIRef, func: _CustomFunction, override: bool = False, raw: bool = False
) -> None: ...
def custom_function(
    uri: URIRef, override: bool = False, raw: bool = False
) -> Callable[[_CustomFunction], _CustomFunction]: ...
def unregister_custom_function(
    uri: URIRef, func: Callable[..., Any] | None = None
) -> None: ...
def Function(e: Expr, ctx: FrozenBindings) -> Node: ...
def default_cast(e: Expr, ctx: FrozenBindings) -> Literal: ...
def UnaryNot(expr: Expr, ctx: FrozenBindings) -> Literal: ...
def UnaryMinus(expr: Expr, ctx: FrozenBindings) -> Literal: ...
def UnaryPlus(expr: Expr, ctx: FrozenBindings) -> Literal: ...
def MultiplicativeExpression(
    e: Expr, ctx: QueryContext | FrozenBindings
) -> Literal: ...
def AdditiveExpression(e: Expr, ctx: QueryContext | FrozenBindings) -> Literal: ...
def RelationalExpression(e: Expr, ctx: QueryContext | FrozenBindings) -> Literal: ...
def ConditionalAndExpression(
    e: Expr, ctx: QueryContext | FrozenBindings
) -> Literal: ...
def ConditionalOrExpression(e: Expr, ctx: QueryContext | FrozenBindings) -> Literal: ...
def not_(arg) -> Expr: ...
def and_(*args: Expr) -> Expr: ...

TrueFilter: Incomplete

def simplify(expr: Any) -> Any: ...
def literal(s: Literal) -> Literal: ...
def datetime(e: Literal) -> py_datetime.datetime: ...
def date(e: Literal) -> py_datetime.date: ...
def string(s: Literal) -> Literal: ...
def numeric(expr: Literal) -> Any: ...
def dateTimeObjects(expr: Literal) -> Any: ...
def isCompatibleDateTimeDatatype(
    obj1: py_datetime.date | py_datetime.datetime,
    dt1: URIRef,
    obj2: Duration | py_datetime.timedelta,
    dt2: URIRef,
) -> bool: ...
def calculateDuration(
    obj1: py_datetime.date | py_datetime.datetime,
    obj2: py_datetime.date | py_datetime.datetime,
) -> Literal: ...
def calculateFinalDateTime(
    obj1: py_datetime.date | py_datetime.datetime,
    dt1: URIRef,
    obj2: Duration | py_datetime.timedelta,
    dt2: URIRef,
    operation: str,
) -> Literal: ...
@overload
def EBV(rt: Literal) -> bool: ...
@overload
def EBV(rt: Variable | IdentifiedNode | SPARQLError | Expr) -> NoReturn: ...
@overload
def EBV(rt: Identifier | SPARQLError | Expr) -> bool | NoReturn: ...
