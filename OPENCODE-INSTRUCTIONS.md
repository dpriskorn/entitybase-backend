# Guiding principles for new entitybase -backend

- Keep it simple, stupid 
- Less is more
- MVP first, non-core features can come later
- Avoid premature optimizations. Caching can wait, let's build something that scales to 1bn+ items accessible for 1 user first, then scale to 100k+ users.
- Keep discrete components small and apart
- Use Python Pydantic and FastAPI framework 
- use Pydantic classes where it makes sense and serialization is needed
- Start small and simple, iterate in small steps
- No threat model, everybody is playing nice
- Start with 1 shard until we get MVP working
- Ask user before editing
- Don't run docker commands
- Never pass unparsed json around between methods - use pydantic model with (data**) as soon as possible
- All api endpoints return JSON
- /raw/ endpoint returns full revision schema, /entity/ endpoint extracts nested entity
- after each edit lets use ./run-linters.sh to check for ruff, dead code, mypy errors
- do this before running pytest:  export PYTHONPATH=/home/dpriskorn/src/python/wikibase-backend/src:$PYTHONPATH && source .venv/bin/activate
- after each edit with new tests lets use pytest to check that new tests pass
- generally one class per file for all classes with at least 1 method
- add single line docstring at the minimum to new classes and methods
- use pydantic models for all dict-style returns from functions in src/
- add at least 1 logger.info() to all methods >20 lines
- all tests have to be marked either unit/integration/e2e
- new data models have to be suffixed with *Request, *Response, *Record (Vitess) or *Data (S3)
- no relative imports
- no __future__ imports
- no strings in code - everything is enums
- no passing tuples or dicts between methods, use pydantic basemodels
- avoid websearch, everything we need is in the repo already just ask where to find what you need
- we don't expose internal_id outside the VitessClient class
- no backward compability
- never use Optional for typing
- str defaults to "" and never None
